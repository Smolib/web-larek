## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```
# Web-Larek
Данный проект - альтернативная версия канонической работы, используемая для обучения студентов Яндекс.Практикума на модуле ООП и Архитектура приложений.

Реализация проекта изначально базируется на готовой сборке, предлагаемой студентам для написания своих работ.
Верстка проекта также реализована сторонними разработчиками.

Основная цель данного проекта - научить студентов правильному использованию паттернов MVP и Observer, с примером на небольшом проекте интернет-магазина.

Что нужно еще доработать для полного исправления всех замечаний к канонической работе:

#### TODO Исправить недостатки верстки и несоответствие макету

1. Есть места, где классы CSS написаны совершенно хаотично, хотя была попытка в БЭМ - надо навести порядок.
2. Прыгающие кнопки - при изменении кол-ва ошибок или при изменении текста кнопок верстка прыгает.
3. Мобильная версия - проект не рассчитан на маленькие экраны + при сжатии до одной карточки в ширину она выглядит некорректно, не отцентровано.
4. Решить проблему с прозрачными изображениями товаров.
5. Убрать перелистывание в начало страницы при открытии модального окна.
6. Просмотреть файлы scss, навести порядок.
7. Уйти от идеи одинаковых css-классов для разных карточек в проекте - это выглядит слабо поддерживаемо.

#### TODO JS

1. Посмотреть функции в utils.ts, поправить там типизацию, возможно упростить.
2. Проверить технические файлы и настройки сборки - на первый взгляд там можно убрать что-то лишнее.

#### TODO Организация кода

1. Описать структуру приложения в README, как этого требуют для сдачи проектной работы на модуле ООП в Яндекс.Практикуме.

#### Осознанные решения и архитектурные принципы, по котором писался проект:

1. Отказ от использования единого экземпляра какого-либо эмиттера для всего проекта, в отличии от работ, предлагаемых студентам Яндекс.Практикума.
    
2. Отказ от использования класса EventEmitter, а использование только методов emit и addListener, которые принадлежат отдельно View и отдельно Model. Эта реализация хорошо показывает суть паттерна Observer, но выглядят не слишком сложно. Возможно добавление метода удаления слушателя - в проекте не понадобился, в шаблоне для студентов лучше давать. Методы дублируются в разных слоях (Model и View) с целью разведения логики по слоям. (Можно сделать все же именно класс EventEmitter, см. Можно лучше)
    
3. Жесткое разграничение каждого слоя друг от друга - в проекте была попытка реализовать максимально идеальную модель MVP и паттерна Observer, а также максимальное следование принципам SOLID и др.
Основные принципы: 

    - Слой Model ничего не знает о других слоях 
    - Слой View ничего не знает о других слоях 
    - Слой Presenter знает о Model и View, их публичных методах и свойствах. 
    - Создание слоев происходит в index.ts, данные View и Model передаются в Presenter, проект декларативно запускается при создании Presenter. 
    - Все типы строго разнесены по слоям - нельзя использовать типизацию из Model во View и наоборот, даже если визуально это один и тот же тип данных. 
    - Также разнесена типизация и логика работы отдельных View - каждый экземпляр View не знает о типах других View, кроме случаев если View генерируют другие View (Basket, Page - смотри пункт "можно лучше"). В связи с этим есть одинаковые типы с разным названием, но копировать или импортировать в другие компоненты их нельзя - это нарушит несвязанность кода. 
    - View и Model не знают, какие действия должны происходить после эмита события. Все, что может сказать View или Model это о факте совершения действия (например, "мою кнопку кликнули" или "я получила новые карточки с сервера"), но никак не о следующем шаге в логике приложения. Нельзя допускать, чтобы эти слои эмитили события вида "открой модальное окно с формой заказа" или "отрендери новые карточки". 
    - Вся логика объединения слоев заключена исключительно в Presenter, с помощью своих колбеков в слушателях он связывает два слоя в единую конструкцию. 
    - Нельзя допускать эмит событий вне экземпляров Model и View, эмитить события могут только те, кто эти события непосредственно и создают.
    
4. Названия компонентов View, Model, Presenter - для более очевидного закрепления что же является чем в нашей MVP-архитектуре. Также строгое разделение по папкам для этого же эффекта.
5. Вся типизация разбита по папкам в types, дублирует такие же директории в components. Другой вариант расположения кода - всю типизацию наоборот держать максимально близко к тому, кто ее использует (в одном и том же файле). Но у нас в чек-листе рекомендация выносить типизацию отдельно. Частичный вариант (типы храним и там и там) не допускается.
6. Все названия типизации Enum, Type и др. начинаются соответственно с Enum и Type и др. для хорошей читаемости.
7. Названия любых сущностей старалась давать в развернутом и максимально однотипном виде, чтобы код хорошо читался. Это удлиняет местами названия, но дает гораздо больше представления о том, что это за переменная/класс/метод и др., а однотипность позволяет быстро понять что это за наименование, не тратя время на вникание в разные варианты наименований похожих сущностей.
8. Максимально использовались Enum, которых нет в изначальных канониклах, для максимального ухода от любых "магических значений". Все классы CSS, названия событий и пр. записаны через Enum - это позволяет легко и быстро менять в проекте какие-либо данные при изменении верстки, к примеру, а также улучшает читаемость кода и сильно уменьшает кол-во ошибок.
9. WebLarekApi не наследует Api, а включает его в себя, т.к. WebLarekApi не расширяет методы, не расширяет поля - здесь визуально больше подходит композиция. Клас Api как утильный вынесен в utils
10. Логика валидации отдана формам, а не Model, т.к. в данном проекте это кажется более корректным. Валидация одной формы не является данными для всего приложения. Также сохранение данных из форм происходит только по окончанию заполнения всего заказа - это позволяет не "гонять" данные через все приложение при любом их изменении. До оформления заказа все данные о нем (кроме товаров в корзине) хранят сами формы. Можно иначе (см. Можно иначе и Можно лучше)
11. Model все еще следит за состоянием корзины, т.к. это уже больше логика всего приложения, а не только корзины - эти данные необходимы разным компонентам приложения.
12. Класс карточек не имеет общего родителя и разбит на три разных класса, с частично пересекающимся кодом. Это сделано из соображений, что эти карточки все же не являются связными, а являются совершенно разными View, используемые с разной версткой и разной логикой работы. Единственное, что позволяло работать единому классу Card - это одинаковые наименования классов CSS в верстке в темплейтах разных карточек. Что не очень некорректно и с точки зрения верстки, и плохо поддерживаемо, и требует держать в уме при изменении проекта эту особенность.

#### Обсуждаемо, можно иначе:

1. Можно усложнить Model, создав еще экземпляры модели для хранения данных форм и корзины, к примеру. Сейчас за состояние форм отвечают сами формы, за состояние корзины (т.к. это логика уже всего приложения) - Model.

2. Можно вернуть валидацию и хранение данных из форм в основную Model, т.к. прям по каноник-каноник варианту MVP (и его "предка" MVC) View совсем ничего не знают о своих данных, но настолько строгая реализация редкая - как минимум наши View уже умеют хранить списко слушателей, поэтому можно отдать им и еще немного данных для хранения.

3. Формы и валидацию можно реализовать как проще, так и сложнее. Можно сделать проще - убрать дженерики, родительские методы и работать с каждой формой отдельно. Код будет проще читать для студентов. Можно наоборот усовершенствовать валидацию (см. Можно лучше)

4. Можно вернуть генерацию карточек в Presenter (а не в Page и в Basket). Код будет проще, но все же корректнее, когда Presenter сам ничего не генерирует. Можно наоборот усложнить и отдать генерацию карточек фабрике (см. Можно лучше).


#### Можно лучше (= сложнее):

1. Можно усложнить логику форм и валидации, и дать возможность полю "метод оплаты" быть необъявленными. Сейчас возникает проблема с типизацией, т.к. варианты выбора метода оплаты строго типизированы. Поэтому реализован выбор метода оплаты сразу. Реализация возможна через усложнение дженериков в Form и проверки отдаваемых данных, как вариант. Также не совсем нравится поведение, что при начале заполнения формы у нас вылезают сразу все ошибки (такая же реализация в каноникле), можно усложнить логику и следить за каждым полем отдельно.

2. Для еще большей абстракции, чтобы Basket и Page не знали о существовании другой View, можно использовать класс фабрики и создавать карточки через нее. С помощью фабрики Presenter получил бы View-компоненты для работы со слушателями, а Basket получил бы список HTML-документов.
Написание фабрики создало бы лишние абстракции и ввод новых паттернов в проект, поэтому здесь выбран подобный компромисс решения проблемы для упрощения.

3. Использовать отдельный утильный класс EventEmitter, через композицию передавать его в каждый (! не использовать единый экземпляр) класс View или Model. Этот класс не используется в проекте, т.к. сильно усложняет код. Возможна реализация через наследование, но композиция выглядит корректнее.
